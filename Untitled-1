

(4 + 5) / x



+ -> add
/ -> div



EmitExpression(expr):
    if expr is binary:
        EmitExpression(expr.right)
        EmitExpression(expr.left)
        EmitOpcode(expr.op)
    if expr is unary:
        EmitExpression(expr.operand)
        EmitOpcode(expr.op)
    if expr is primary:
        if expr is identifier:
            EmitInstruction(LOAD, GetAddressOf(expr.id))
        if expr is integer:
            EmitInstruction(PUSH, expr.value)

(/ (+ 4 5) x)

push 5
push 4
add
load $x
div


label      | size
x_i_129038 | 4  


Basic Block: Block of sequential instructions, where no divergent branching can happen.

if x > 2 {
    x = 1;
}
else if x & 5 == 1 {
    ...
}
else {
    x = 4;
}


load $x
push 2
gt
branch BRANCH_0
load $x
push 5
and
push 1
eq
branch BRANCH_2
jump BRANCH_EXIT

BRANCH_0:
    load $x
    push 1
    store
    jump BRANCH_EXIT
BRANCH_2:
    ...
    jump BRANCH_EXIT
BRANCH_1:
    load $x
    push 4
    store
    jump BRANCH_EXIT
BRANCH_EXIT:


while x < 100 {
    x = x + 1;
    break; // jump LBRANCH_EXIT
    continue // jump LBRANCH_0
}


LBRANCH_0:
    load $x 
    push 100
    lt
    branch_z LBRANCH_EXIT

    inc $x

    jump LBRANCH_0

LBRANCH_EXIT:



int i = 0;
for(i = 0; i < 100; i += 2){
    ...
}
i = ??

LBRANCH_0_INIT:
    push 0
    store $x
LBRANCH_0:
    load $i 
    push 100
    lt
    branch_z LBRANCH_EXIT

    ...

    jump LBRANCH_0_NEXT

    LBRANCH_0_NEXT:
        push 2
        add_store $x
    jump LBRANCH_0

LBRANCH_EXIT:

